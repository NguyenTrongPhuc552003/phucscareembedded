---
sidebar_position: 3
---

# Signal Handling

Master RISC-V signal handling that delivers signals to user processes, understanding how signals are generated, how signal handlers are invoked, and how signal masks control signal delivery essential for process management and signal-based communication.

## What Is Signal Handling?

**What**: Signal handling is the mechanism by which the kernel delivers asynchronous notifications (signals) to user processes, allowing processes to handle events like interrupts, errors, and inter-process communication. Signals are delivered to user space signal handlers that processes register.

**Why**: Understanding signal handling is crucial because:

- **Process Communication** - Signals enable inter-process communication
- **Error Handling** - Processes can handle errors via signals
- **Event Notification** - Signals notify processes of events
- **Process Control** - Signals can control process execution
- **Signal Safety** - Must handle signals safely in handlers
- **Kernel Operation** - Fundamental to process management

**When**: Signal handling is used when:

- **Signal Generation** - Signal generated for process
- **Signal Delivery** - Kernel delivers signal to process
- **Handler Invocation** - Signal handler is invoked
- **Signal Masking** - Signals are blocked/unblocked
- **Signal Queue** - Signals are queued for delivery
- **Signal Return** - Returning from signal handler

**How**: Signal handling works through:

- **Signal Generation** - Signal generated by kernel or process
- **Signal Queue** - Signals queued in process signal queue
- **Delivery Check** - Check if signal can be delivered
- **Handler Invocation** - Invoke user space signal handler
- **Context Setup** - Setup user space context for handler
- **Handler Return** - Return from handler using rt_sigreturn

**Where**: Signal handling is found in:

- **Signal Delivery** - kernel/signal.c
- **Signal Queue** - Task signal queue
- **Handler Setup** - Setup signal frame for handler
- **Handler Return** - rt_sigreturn system call
- **Signal Mask** - Process signal mask

## Signal Types

**What**: Signals are numbered events that can be delivered to processes.

**How**: Signal types work:

```c
// Example: Standard signal numbers
// Defined in <signal.h>

#define SIGHUP     1   // Hangup
#define SIGINT     2   // Interrupt (Ctrl-C)
#define SIGQUIT    3   // Quit
#define SIGILL     4   // Illegal instruction
#define SIGTRAP    5   // Trace/breakpoint trap
#define SIGABRT    6   // Abort
#define SIGBUS     7   // Bus error
#define SIGFPE     8   // Floating point exception
#define SIGKILL    9   // Kill (cannot be caught)
#define SIGUSR1   10   // User-defined signal 1
#define SIGSEGV   11   // Segmentation violation
#define SIGUSR2   12   // User-defined signal 2
#define SIGPIPE   13   // Broken pipe
#define SIGALRM   14   // Alarm clock
#define SIGTERM   15   // Termination
#define SIGSTKFLT 16   // Stack fault
#define SIGCHLD   17   // Child status changed
#define SIGCONT   18   // Continue if stopped
#define SIGSTOP   19   // Stop (cannot be caught)
#define SIGTSTP   20   // Terminal stop signal
#define SIGTTIN   21   // Terminal input for background process
#define SIGTTOU   22   // Terminal output for background process
#define SIGURG    23   // Urgent condition on socket
#define SIGXCPU   24   // CPU time limit exceeded
#define SIGXFSZ   25   // File size limit exceeded
#define SIGVTALRM 26   // Virtual alarm clock
#define SIGPROF   27   // Profiling timer expired
#define SIGWINCH  28   // Window size change
#define SIGIO     29   // I/O now possible
#define SIGPWR    30   // Power failure
#define SIGSYS    31   // Bad system call

// Example: Signal categories
#define SIGRTMIN  32   // First real-time signal
#define SIGRTMAX  64   // Last real-time signal

// Real-time signals: 32-64
// Standard signals: 1-31

// Example: Signal properties
// Some signals cannot be caught or ignored:
// - SIGKILL: Always terminates process
// - SIGSTOP: Always stops process

// Example: Signal default actions
// Default action when no handler installed:
// - Terminate: SIGHUP, SIGINT, SIGQUIT, SIGTERM, etc.
// - Ignore: SIGCHLD, SIGURG, SIGWINCH, etc.
// - Core dump: SIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGFPE, SIGSEGV, SIGBUS, etc.
// - Stop: SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU
// - Continue: SIGCONT
```

**Explanation**:

- **Signal numbers** each signal has unique number
- **Standard signals** signals 1-31 are standard signals
- **Real-time signals** signals 32-64 are real-time signals
- **Signal properties** some signals have special properties
- **Default actions** signals have default actions if no handler

## Signal Generation

**What**: Signals are generated by the kernel or by other processes.

**How**: Signal generation works:

```c
// Example: Kernel signal generation
// Kernel generates signals for various reasons

// Example: Generate signal for process
int send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p) {
    // Generate signal 'sig' for process 'p'

    // Check if signal can be sent
    if (!valid_signal(sig)) {
        return -EINVAL;
    }

    // Check permissions
    if (!may_send_signal(p, sig)) {
        return -EPERM;
    }

    // Queue signal
    return __send_signal(sig, info, p, PIDTYPE_PID, false);
}

// Example: Sending signal from user space (kill system call)
asmlinkage long sys_kill(const struct pt_regs *regs) {
    pid_t pid = regs->a0;
    int sig = regs->a1;

    struct kernel_siginfo info;

    // Setup siginfo
    clear_siginfo(&info);
    info.si_signo = sig;
    info.si_code = SI_USER;  // From user space
    info.si_pid = current->tgid;
    info.si_uid = current_uid().val;

    // Send signal
    return kill_something_info(sig, &info, pid);
}

// Example: Generate signal on exception
void force_sig_fault(int sig, int code, unsigned long addr, struct task_struct *tsk) {
    struct kernel_siginfo info;

    // Setup siginfo for fault
    clear_siginfo(&info);
    info.si_signo = sig;
    info.si_code = code;  // Fault code
    info.si_addr = (void __user *)addr;  // Fault address

    // Send signal
    force_sig_info(&info, tsk);
}

// Example: Signal on page fault
void do_page_fault(struct pt_regs *regs, unsigned long addr) {
    // Handle page fault
    // If fault cannot be handled, send SIGSEGV

    if (!fixup_page_fault(regs, addr)) {
        // Cannot fix fault, send signal
        force_sig_fault(SIGSEGV, SEGV_MAPERR, addr, current);
    }
}

// Example: Signal on illegal instruction
void do_illegal_instruction(struct pt_regs *regs) {
    // Generate SIGILL
    force_sig_fault(SIGILL, ILL_ILLOPC, regs->epc, current);
}

// Example: Signal on floating point exception
void do_fpe(struct pt_regs *regs, unsigned long cause) {
    // Generate SIGFPE
    force_sig_fault(SIGFPE, FPE_FLTINV, regs->epc, current);
}

// Example: Timer signal (SIGALRM)
void alarm_firing(struct callback_head *work) {
    struct task_struct *tsk = current;

    // Send SIGALRM
    send_sig(SIGALRM, tsk, 0);
}
```

**Explanation**:

- **Kernel generation** kernel generates signals automatically
- **User generation** processes can send signals via kill()
- **Exception signals** exceptions can generate signals
- **Fault signals** page faults generate SIGSEGV
- **Timer signals** timers can generate signals
- **Signal info** siginfo structure contains signal details

## Signal Queue and Delivery

**What**: Signals are queued in process signal queue and delivered when process returns to user space.

**How**: Signal queue and delivery works:

```c
// Example: Signal queue structure
// Each process has signal queue

struct task_struct {
    // ...
    struct sigpending pending;  // Pending signals
    sigset_t blocked;            // Blocked signal mask
    sigset_t real_blocked;       // Real blocked signals
    struct sigaction sigaction[_NSIG];  // Signal handlers
    // ...
};

// Signal pending structure
struct sigpending {
    struct list_head list;
    sigset_t signal;
};

// Signal queue entry
struct sigqueue {
    struct list_head list;
    struct kernel_siginfo info;
};

// Example: Queue signal
int __send_signal(int sig, struct kernel_siginfo *info,
                  struct task_struct *t, int group, int from_ancestor) {
    struct sigqueue *q;

    // Allocate signal queue entry
    q = __sigqueue_alloc(sig, t, GFP_ATOMIC, 0, 0);

    if (!q) {
        // Could not allocate, use synchronous delivery
        return send_signal(sig, info, t, PIDTYPE_PID);
    }

    // Copy signal info
    copy_siginfo(&q->info, info);

    // Add to signal queue
    list_add_tail(&q->list, &t->pending.list);

    // Set signal bit in pending mask
    sigaddset(&t->pending.signal, sig);

    // Wake up process if sleeping
    signal_wake_up(t, 0);

    return 0;
}

// Example: Check for pending signals
bool has_pending_signals(sigset_t *set, struct task_struct *tsk) {
    // Check if any signals in set are pending
    sigset_t pending;

    // Get pending signals
    sigandsets(&pending, &tsk->pending.signal, set);

    // Exclude blocked signals
    sigandnsets(&pending, &pending, &tsk->blocked);

    return !sigisemptyset(&pending);
}

// Example: Signal delivery
void do_signal(struct pt_regs *regs) {
    struct k_sigaction ka;
    int signr;

    // Get pending signal (not blocked)
    signr = get_signal(&ka);

    if (signr > 0) {
        // Deliver signal
        handle_signal(&ka, signr, regs);
        return;
    }

    // No signal to deliver, restore previous context
    restore_saved_sigmask();
}

// Example: Get next signal to deliver
int get_signal(struct k_sigaction *ka) {
    struct task_struct *tsk = current;
    sigset_t *mask = &tsk->pending.signal;
    int signr;

    // Check for pending signals
    if (sigisemptyset(mask)) {
        return 0;  // No pending signals
    }

    // Find first pending, non-blocked signal
    for (signr = 1; signr <= _NSIG; signr++) {
        if (sigismember(mask, signr)) {
            // Signal is pending
            if (sigismember(&tsk->blocked, signr)) {
                continue;  // Signal is blocked
            }

            // Get signal handler
            *ka = tsk->sighand->action[signr - 1];

            // Remove from pending
            sigdelset(mask, signr);

            return signr;
        }
    }

    return 0;  // No deliverable signals
}
```

**Explanation**:

- **Signal queue** signals queued in process pending list
- **Queue entry** each signal has queue entry with info
- **Pending mask** bitmask tracks pending signals
- **Blocked signals** blocked signals not delivered
- **Delivery check** check for pending, non-blocked signals
- **Signal removal** remove signal from queue on delivery

## Signal Handler Invocation

**What**: Signal handlers are invoked by setting up user space context and jumping to handler.

**How**: Handler invocation works:

```c
// Example: Signal frame structure
// Signal frame on user stack contains saved context

struct rt_sigframe {
    struct siginfo info;
    struct ucontext uc;
    unsigned long trampoline;  // Return trampoline
};

// ucontext contains saved registers
struct ucontext {
    unsigned long uc_flags;
    struct ucontext *uc_link;
    stack_t uc_stack;
    struct sigcontext uc_mcontext;
    sigset_t uc_sigmask;
};

// Signal handler is called with:
// - Signal number
// - siginfo pointer
// - ucontext pointer

// Example: Setup signal frame and invoke handler
void handle_signal(struct k_sigaction *ka, int signr,
                   struct pt_regs *regs) {
    // Allocate signal frame on user stack
    struct rt_sigframe __user *frame;
    unsigned long sp;

    // Calculate new stack pointer
    sp = sigsp(regs->sp, ka);
    sp = align_sigframe(sp);
    sp -= sizeof(*frame);

    frame = (struct rt_sigframe __user *)sp;

    // Validate stack pointer
    if (!access_ok(frame, sizeof(*frame))) {
        force_sig(SIGSEGV);
        return;
    }

    // Setup signal frame
    if (copy_siginfo_to_user(&frame->info, get_siginfo(signr))) {
        force_sig(SIGSEGV);
        return;
    }

    // Save current register context
    setup_sigcontext(&frame->uc.uc_mcontext, regs);

    // Setup signal mask
    if (copy_to_user(&frame->uc.uc_sigmask, &current->blocked,
                     sizeof(sigset_t))) {
        force_sig(SIGSEGV);
        return;
    }

    // Setup return trampoline (rt_sigreturn)
    frame->trampoline = (unsigned long)__kernel_rt_sigreturn;

    // Modify registers to call signal handler
    regs->epc = (unsigned long)ka->sa.sa_handler;  // Handler address
    regs->sp = (unsigned long)frame;                // New stack
    regs->a0 = signr;                               // Signal number
    regs->a1 = (unsigned long)&frame->info;        // siginfo pointer
    regs->a2 = (unsigned long)&frame->uc;          // ucontext pointer

    // When returning to user space, handler will be called
}

// Example: Return from signal handler (rt_sigreturn)
asmlinkage long sys_rt_sigreturn(const struct pt_regs *regs) {
    struct rt_sigframe __user *frame;
    struct ucontext __user *uc;
    sigset_t set;

    // Get signal frame address from stack
    frame = (struct rt_sigframe __user *)regs->sp;
    uc = &frame->uc;

    // Restore signal mask
    if (copy_from_user(&set, &uc->uc_sigmask, sizeof(sigset_t))) {
        goto badframe;
    }

    set_current_blocked(&set);

    // Restore register context
    if (restore_sigcontext(regs, &uc->uc_mcontext)) {
        goto badframe;
    }

    // Return to original execution point
    return 0;

badframe:
    force_sig(SIGSEGV);
    return 0;
}

// Example: Signal handler trampoline
// Assembly code to call rt_sigreturn
__kernel_rt_sigreturn:
    li a7, __NR_rt_sigreturn
    ecall
    # Should never return
```

**Explanation**:

- **Signal frame** frame on user stack contains saved context
- **Frame setup** setup frame with saved registers and info
- **Handler call** modify registers to call handler
- **Trampoline** trampoline calls rt_sigreturn
- **Context restore** restore original context from frame
- **Return handling** return to original execution point

## Signal Mask and Blocking

**What**: Signal mask controls which signals are blocked from delivery.

**How**: Signal masking works:

```c
// Example: Signal mask operations
// Signal mask is sigset_t bitmask

// Example: Block signals (sigprocmask)
asmlinkage long sys_rt_sigprocmask(const struct pt_regs *regs) {
    int how = regs->a0;
    sigset_t __user *set = (sigset_t __user *)regs->a1;
    sigset_t __user *oldset = (sigset_t __user *)regs->a2;
    size_t sigsetsize = regs->a3;

    sigset_t new_set, old_set;

    if (sigsetsize != sizeof(sigset_t)) {
        return -EINVAL;
    }

    // Get old mask
    old_set = current->blocked;

    if (oldset) {
        if (copy_to_user(oldset, &old_set, sizeof(sigset_t))) {
            return -EFAULT;
        }
    }

    // Get new mask if provided
    if (set) {
        if (copy_from_user(&new_set, set, sizeof(sigset_t))) {
            return -EFAULT;
        }

        // Apply mask according to 'how'
        switch (how) {
        case SIG_BLOCK:
            // Block signals: block = block | new_set
            sigorsets(&current->blocked, &current->blocked, &new_set);
            break;

        case SIG_UNBLOCK:
            // Unblock signals: block = block & ~new_set
            sigandnsets(&current->blocked, &current->blocked, &new_set);
            break;

        case SIG_SETMASK:
            // Set mask: block = new_set
            current->blocked = new_set;
            break;

        default:
            return -EINVAL;
        }

        // Recalculate pending signals
        recalc_sigpending();
    }

    return 0;
}

// Example: Block signals during critical section
void block_signals(sigset_t *oldset) {
    sigset_t new_set;

    // Block all signals
    sigfillset(&new_set);

    // Block and save old mask
    set_current_blocked(&new_set);

    // Save old mask
    if (oldset) {
        *oldset = current->blocked;
    }
}

void unblock_signals(sigset_t *oldset) {
    // Restore old mask
    if (oldset) {
        set_current_blocked(oldset);
    }
}

// Example: Check if signal is blocked
bool signal_blocked(int sig, struct task_struct *tsk) {
    return sigismember(&tsk->blocked, sig);
}

// Example: Check pending, non-blocked signals
int dequeue_signal(struct task_struct *tsk, sigset_t *mask,
                   struct kernel_siginfo *info) {
    sigset_t *pending = &tsk->pending.signal;
    sigset_t work;
    int sig;

    // Get pending signals not in mask
    sigandsets(&work, pending, mask);
    sigandnsets(&work, &work, &tsk->blocked);

    // Find first signal
    sig = _next_signal(&work, info);

    if (sig) {
        // Remove from pending
        sigdelset(pending, sig);
        recalc_sigpending();
    }

    return sig;
}
```

**Explanation**:

- **Signal mask** sigset_t bitmask tracks blocked signals
- **Block operations** SIG_BLOCK, SIG_UNBLOCK, SIG_SETMASK
- **Blocked signals** blocked signals not delivered
- **Critical sections** block signals during critical sections
- **Pending queue** blocked signals remain in pending queue
- **Recalculation** recalculate pending when mask changes

## Next Steps

**What** you're ready for next:

After understanding signal handling, you should be ready to:

1. **Learn User/Kernel Transitions** - Detailed transition mechanisms
2. **Explore System Call Tracing** - Debugging system calls
3. **Study Process Management** - Process lifecycle and management
4. **Understand Debugging** - Signal debugging techniques
5. **Begin Signal Programming** - Write signal-based programs

**Where** to go next:

Continue with the next lesson on **"User/Kernel Transitions"** to learn:

- Detailed transition mechanisms
- Entry/exit optimizations
- Security considerations
- Performance optimizations
- Debugging techniques

**Why** the next lesson is important:

User/kernel transitions are fundamental to system operation. Understanding these in detail is essential for kernel development and optimization.

**How** to continue learning:

1. **Study Kernel Code** - Examine transition code in detail
2. **Use Debugger** - Debug transitions
3. **Trace Execution** - Trace transition flow
4. **Read Documentation** - Study RISC-V transition documentation
5. **Experiment** - Modify transition code and observe

## Resources

**Official Documentation**:

- [Linux Signals](https://man7.org/linux/man-pages/man7/signal.7.html) - Signal documentation
- [RISC-V Privileged ISA](https://github.com/riscv/riscv-isa-manual) - Exception specification

**Kernel Sources**:

- [Linux Signal Handling](https://github.com/torvalds/linux/tree/master/kernel/signal.c) - Signal code
